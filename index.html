<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#4285f4" />
    <title>Cryptoquote</title>
    <link rel="shortcut icon" href="src/images/icon.svg" type="image/svg" />
    <link rel="manifest" href="src/manifest.webmanifest" />
  </head>

  <body>
    <main id="main">
      <h1>Cryptoquote</h1>
      <hr />

      <section>
        <h5>Enter encrypted text</h5>
        <details open>
          <summary></summary>
          <div id="ciphertext-input-container">
            <textarea
              id="ciphertext-input"
              placeholder="Enter encrypted text"
            ></textarea>
          </div>
          <a href="#" id="reset">Reset</a>
        </details>
      </section>
      <hr />

      <section>
        <p id="ciphertext"></p>
      </section>

      <section>
        <input type="text" id="dummy-input" />
        <p id="plaintext"></p>
        <a href="#" id="clear">Clear</a>
      </section>
      <hr />

      <section>
        <h5>Remaining letters</h5>
        <p>
          <span id="unused-letters"></span>
        </p>
        <p>
          <span id="used-letters"></span>
        </p>
      </section>
      <hr />

      <section>
        <details>
          <summary>Hint: Character counts</summary>
          <p id="ciphertext-char-tally"></p>
        </details>
      </section>
    </main>
  </body>

  <style>
    html {
      font-family: 'Courier New', Courier, monospace;
      font-size: x-large;
      overflow-wrap: break-word;
      background-image: url(./src/images/background.jpg);
      background-size: cover;
    }
    #main {
      max-width: 500px;
      margin: auto;
    }
    h1,
    h5 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }
    a {
      font-size: medium;
    }
    #ciphertext-input-container {
      padding: 0 20px 0 20px;
    }
    #ciphertext-input {
      width: 100%;
      height: 100px;
    }
    .highlight {
      background-color: yellow;
    }
    .char {
      margin-right: 0.1rem;
    }
    #plaintext .char {
      text-decoration: underline;
      text-decoration-color: black;
      text-decoration-thickness: 1px;
    }
    [data-used-letter] {
      color: gray;
      text-decoration: line-through;
    }
    #dummy-input {
      position: absolute;
      left: -9999px;
    }
    #ciphertext-char-tally {
      display: grid;
      grid-auto-flow: column;
      grid-template-rows: repeat(9, auto);
      grid-template-columns: repeat(3, auto);
    }
  </style>

  <script>
    /**
     * HTML elements
     */
    const ciphertextInputElement = document.querySelector('#ciphertext-input');
    const ciphertextElement = document.querySelector('#ciphertext');
    const plaintextElement = document.querySelector('#plaintext');
    const unusedLettersElement = document.querySelector('#unused-letters');
    const usedLettersElement = document.querySelector('#used-letters');
    const ciphertextCharTallyElement = document.querySelector(
      '#ciphertext-char-tally'
    );
    const dummyInput = document.querySelector('#dummy-input');

    /**
     * Global variables
     */
    let selectedChar;
    let translationMap = {};

    /**
     * Update state
     */
    function updateCiphertext(newCiphertext) {
      localStorage.ciphertext = newCiphertext.toUpperCase();
      renderCiphertext();
      renderPlaintext();
      renderCharTally();
      addClickListeners();
    }

    /**
     * Update DOM
     */
    function renderCiphertextInput() {
      ciphertextInputElement.value = localStorage.ciphertext;
    }

    function renderCiphertext() {
      ciphertextElement.innerHTML = localStorage.ciphertext
        .split('')
        .map((char) => {
          if (Object.keys(translationMap).includes(char)) {
            return `<span class="char" data-ciphertext-char="${char}" data-used-letter>${char}</span>`;
          } else if (/[A-Z]/.test(char)) {
            return `<span class="char" data-ciphertext-char="${char}">${char}</span>`;
          } else if (char === '\n') {
            return '<br />';
          } else {
            return char;
          }
        })
        .join('');
    }

    function renderPlaintext() {
      plaintextElement.innerHTML = localStorage.ciphertext
        .split('')
        .map((char) => {
          if (translationMap[char]) {
            return `<span class="char" data-ciphertext-char="${char}">${translationMap[char]}</span>`;
          } else if (/[A-Z]/.test(char)) {
            // Using transparent '_' instead of ' ' for testability
            return `<span class="char" data-ciphertext-char="${char}" style='color: transparent;'>_</span>`;
          } else if (char === '\n') {
            return '<br />';
          } else {
            return char;
          }
        })
        .join('');
    }

    function renderUsedLetters() {
      const usedLetters = Object.values(translationMap).sort();
      const unusedLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        .split('')
        .filter((char) => !usedLetters.includes(char));

      unusedLettersElement.innerHTML = unusedLetters
        .map((char) => `<span class="char">${char}</span>`)
        .join('');
      usedLettersElement.innerHTML = usedLetters
        .map((char) => {
          const dataCiphertextChar = Object.entries(translationMap).find(
            ([key, value]) => value === char
          )[0];
          return `<span class="char" data-ciphertext-char="${dataCiphertextChar}" data-used-letter>${char}</span>`;
        })
        .join('');
    }

    function renderCharTally() {
      const ciphertextCharTally = {};
      localStorage.ciphertext
        .replace(/[^A-Z]/g, '')
        .split('')
        .forEach((char) =>
          ciphertextCharTally[char]
            ? (ciphertextCharTally[char] += 1)
            : (ciphertextCharTally[char] = 1)
        );
      const rowCount = Math.ceil(Object.keys(ciphertextCharTally).length / 3);
      ciphertextCharTallyElement.style[
        'grid-template-rows'
      ] = `repeat(${rowCount}, auto`;
      ciphertextCharTallyElement.innerHTML = Object.entries(ciphertextCharTally)
        .sort(([_char1, tally1], [_char2, tally2]) => tally2 - tally1)
        .map(([char, tally]) => {
          const isUsedLetter = Object.keys(translationMap).includes(char);
          return `<div class="char" data-ciphertext-char="${char}" ${
            isUsedLetter ? 'data-used-letter' : ''
          }>${char}: ${tally}</div>`;
        })
        .join('');
    }

    function addClickListeners() {
      const allCharElements = document.querySelectorAll('.char');
      allCharElements.forEach((charElement) => {
        charElement.addEventListener('click', () => {
          allCharElements.forEach((charElement) =>
            charElement.classList.remove('highlight')
          );
          selectedChar = charElement.getAttribute('data-ciphertext-char');
          const selectedCharElements = document.querySelectorAll(
            `.char[data-ciphertext-char="${selectedChar}"]`
          );
          selectedCharElements.forEach((selectedCharElement) =>
            selectedCharElement.classList.add('highlight')
          );
          dummyInput.focus();
        });
      });
    }

    function unselectChar() {
      document
        .querySelectorAll('.char')
        .forEach((charElement) => charElement.classList.remove('highlight'));

      selectedChar = null;
    }

    function handleDummyInputKeyUp(event) {
      if (!selectedChar) return;
      const key = event.key;
      if (key === 'Escape') {
        unselectChar();
      } else if (key === 'Backspace' || key === 'Delete') {
        delete translationMap[selectedChar];
        renderCiphertext();
        renderPlaintext();
        renderUsedLetters();
        renderCharTally();
        addClickListeners();
        unselectChar();
      }
    }

    function handleDummyInput() {
      const dummyInputValue = dummyInput.value.toUpperCase();
      dummyInput.value = null;

      if (!selectedChar) {
        console.error('No character selected');
        return;
      } else if (!dummyInputValue.match(/^[A-Z]$/)) {
        console.error('Input more than a single character: ', dummyInputValue);
        return;
      }

      Object.entries(translationMap).forEach(
        ([ciphertextChar, plaintextChar]) => {
          if (plaintextChar === dummyInputValue) {
            delete translationMap[ciphertextChar];
          }
        }
      );

      translationMap[selectedChar] = dummyInputValue;
      renderCiphertext();
      renderPlaintext();
      renderUsedLetters();
      renderCharTally();
      addClickListeners();

      dummyInput.blur();
    }

    function reset() {
      localStorage.clear();
      translationMap = {};
      load();
    }

    function load() {
      ciphertext = localStorage.ciphertext || '';
      updateCiphertext(ciphertext);
      renderCiphertextInput();
      renderUsedLetters();
    }

    function clear() {
      translationMap = {};
      load();
    }

    load();

    /**
     * Add event listeners
     */
    ciphertextInputElement.addEventListener('input', (event) =>
      updateCiphertext(event.target.value)
    );

    // The purpose of this dummy input is twofold: 1) mobile keyboards won't come up unless an input field is in focus, and 2) mobile keyboards (specifically Android) don't recognize the `event.key` on keydown/keyup events, so this captures the key by reading the input value.
    dummyInput.addEventListener('keyup', handleDummyInputKeyUp);
    dummyInput.addEventListener('input', handleDummyInput);
    dummyInput.addEventListener('blur', unselectChar);

    document.querySelector('#reset').addEventListener('click', reset);

    document.querySelector('#clear').addEventListener('click', clear);
  </script>
</html>
