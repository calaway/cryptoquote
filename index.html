<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cryptoquote</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“œ</text></svg>"
    />
  </head>

  <body>
    <main id="main">
      <h1>Cryptoquote</h1>
      <hr />

      <section>
        <hgroup>
          <h4>Enter encrypted text</h4>
          <button class="hide-button">Collapse</button>
        </hgroup>
        <div class="hideable">
          <textarea
            id="ciphertext-input"
            placeholder="Enter encrypted text"
          ></textarea>
          <button id="reset">Reset</button>
        </div>
      </section>
      <hr />

      <section>
        <p id="ciphertext"></p>
      </section>
      <hr />

      <section>
        <input type="text" id="dummy-input" />
        <p id="plaintext"></p>
        <button id="clear">Clear</button>
      </section>
      <hr />

      <section>
        <p>
          <span style="font-weight: bold">Unused:</span>
          <span id="unused-letters"></span>
        </p>
        <p>
          <span style="font-weight: bold">Used:</span>
          <span id="used-letters"></span>
        </p>
      </section>
      <hr />

      <section>
        <hgroup>
          <h4>Hint: Character counts</h4>
          <button class="hide-button">Show</button>
        </hgroup>
        <div class="hideable" hidden>
          <p id="ciphertext-char-tally"></p>
        </div>
      </section>
    </main>
  </body>

  <style>
    html {
      font-family: 'Courier New', Courier, monospace;
      font-size: x-large;
      background-image: url(./images/background.jpg);
      background-size: cover;
    }
    #main {
      max-width: 500px;
      margin: auto;
    }
    hgroup {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #ciphertext-input {
      width: 100%;
      height: 100px;
    }
    .highlight {
      background-color: yellow;
    }
    .char {
      margin-right: 0.1rem;
    }
    #plaintext .char {
      text-decoration: underline;
      text-decoration-color: black;
      text-decoration-thickness: 1px;
    }
    [data-used-letter] {
      color: gray;
      text-decoration: line-through;
    }
    #dummy-input {
      position: absolute;
      left: -9999px;
    }
    #ciphertext-char-tally {
      display: grid;
      grid-auto-flow: column;
      grid-template-rows: repeat(9, auto);
      grid-template-columns: repeat(3, auto);
    }
  </style>

  <script>
    /**
     * HTML elements
     */
    const ciphertextInputElement = document.querySelector('#ciphertext-input');
    const ciphertextElement = document.querySelector('#ciphertext');
    const plaintextElement = document.querySelector('#plaintext');
    const unusedLettersElement = document.querySelector('#unused-letters');
    const usedLettersElement = document.querySelector('#used-letters');
    const ciphertextCharTallyElement = document.querySelector(
      '#ciphertext-char-tally'
    );
    const dummyInput = document.querySelector('#dummy-input');

    /**
     * Global variables
     */
    let selectedChar;
    let translationMap = {};

    /**
     * Update state
     */
    function updateCiphertext(newCiphertext) {
      localStorage.ciphertext = newCiphertext.toUpperCase();
      renderCiphertext();
      renderPlaintext();
      renderCharTally();
      addClickListeners();
    }

    /**
     * Update DOM
     */
    function renderCiphertextInput() {
      ciphertextInputElement.value = localStorage.ciphertext;
    }

    function renderCiphertext() {
      ciphertextElement.innerHTML = localStorage.ciphertext
        .split('')
        .map((char) => {
          if (Object.keys(translationMap).includes(char)) {
            return `<span class="char" data-ciphertext-char="${char}" data-used-letter>${char}</span>`;
          } else if (/[A-Z]/.test(char)) {
            return `<span class="char" data-ciphertext-char="${char}">${char}</span>`;
          } else if (char === '\n') {
            return '<br />';
          } else {
            return char;
          }
        })
        .join('');
    }

    function renderPlaintext() {
      plaintextElement.innerHTML = localStorage.ciphertext
        .split('')
        .map((char) => {
          if (translationMap[char]) {
            return `<span class="char" data-ciphertext-char="${char}">${translationMap[char]}</span>`;
          } else if (/[A-Z]/.test(char)) {
            // Using transparent '_' instead of ' ' for testability
            return `<span class="char" data-ciphertext-char="${char}" style='color: transparent;'>_</span>`;
          } else if (char === '\n') {
            return '<br />';
          } else {
            return char;
          }
        })
        .join('');
    }

    function renderUsedLetters() {
      const usedLetters = Object.values(translationMap).sort();
      const unusedLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        .split('')
        .filter((char) => !usedLetters.includes(char));

      unusedLettersElement.innerHTML = unusedLetters
        .map(
          (char) =>
            `<span class="char" style="overflow-wrap: anywhere;">${char}</span>`
        )
        .join('');
      usedLettersElement.innerHTML = usedLetters
        .map((char) => {
          const dataCiphertextChar = Object.entries(translationMap).find(
            ([key, value]) => value === char
          )[0];
          return `<span class="char" data-ciphertext-char="${dataCiphertextChar}" data-used-letter style="overflow-wrap: anywhere;">${char}</span>`;
        })
        .join('');
    }

    function renderCharTally() {
      const ciphertextCharTally = {};
      localStorage.ciphertext
        .replace(/[^A-Z]/g, '')
        .split('')
        .forEach((char) =>
          ciphertextCharTally[char]
            ? (ciphertextCharTally[char] += 1)
            : (ciphertextCharTally[char] = 1)
        );
      ciphertextCharTallyElement.innerHTML = Object.entries(ciphertextCharTally)
        .sort(([_char1, tally1], [_char2, tally2]) => tally2 - tally1)
        .map(([char, tally]) => {
          const isUsedLetter = Object.keys(translationMap).includes(char);
          return `<div class="char" data-ciphertext-char="${char}" ${
            isUsedLetter ? 'data-used-letter' : ''
          }>${char}: ${tally}</div>`;
        })
        .join('');
    }

    function addClickListeners() {
      const allCharElements = document.querySelectorAll('.char');
      allCharElements.forEach((charElement) => {
        charElement.addEventListener('click', () => {
          allCharElements.forEach((charElement) =>
            charElement.classList.remove('highlight')
          );
          selectedChar = charElement.getAttribute('data-ciphertext-char');
          const selectedCharElements = document.querySelectorAll(
            `.char[data-ciphertext-char="${selectedChar}"]`
          );
          selectedCharElements.forEach((selectedCharElement) =>
            selectedCharElement.classList.add('highlight')
          );
          dummyInput.focus();
        });
      });
    }

    function unselectChar() {
      document
        .querySelectorAll('.char')
        .forEach((charElement) => charElement.classList.remove('highlight'));

      selectedChar = null;
    }

    function handleDummyInputKeyUp(event) {
      if (!selectedChar) return;
      const key = event.key;
      if (key === 'Escape') {
        unselectChar();
      } else if (key === 'Backspace' || key === 'Delete') {
        delete translationMap[selectedChar];
        renderCiphertext();
        renderPlaintext();
        renderUsedLetters();
        renderCharTally();
        addClickListeners();
        unselectChar();
      }
    }

    function handleDummyInput() {
      const dummyInputValue = dummyInput.value.toUpperCase();
      dummyInput.value = null;

      if (!selectedChar) {
        console.error('No character selected');
        return;
      } else if (!dummyInputValue.match(/^[A-Z]$/)) {
        console.error('Input more than a single character: ', dummyInputValue);
        return;
      }

      Object.entries(translationMap).forEach(
        ([ciphertextChar, plaintextChar]) => {
          if (plaintextChar === dummyInputValue) {
            delete translationMap[ciphertextChar];
          }
        }
      );

      translationMap[selectedChar] = dummyInputValue;
      renderCiphertext();
      renderPlaintext();
      renderUsedLetters();
      renderCharTally();
      addClickListeners();

      dummyInput.blur();
    }

    function reset() {
      localStorage.clear();
      translationMap = {};
      load();
    }

    function load() {
      ciphertext = localStorage.ciphertext || '';
      updateCiphertext(ciphertext);
      renderCiphertextInput();
      renderUsedLetters();
    }

    function clear() {
      translationMap = {};
      load();
    }

    function toggleHideNextElement(event) {
      const hideableElement = event.target.parentElement.parentElement.querySelector(
        '.hideable'
      );
      hideableElement.toggleAttribute('hidden');
      if (hideableElement.hidden) {
        event.target.innerHTML = 'Show';
      } else {
        event.target.innerHTML = 'Hide';
      }
    }

    load();

    /**
     * Add event listeners
     */
    ciphertextInputElement.addEventListener('input', (event) =>
      updateCiphertext(event.target.value)
    );

    // The purpose of this dummy input is twofold: 1) mobile keyboards won't come up unless an input field is in focus, and 2) mobile keyboards (specifically Android) don't recognize the `event.key` on keydown/keyup events, so this captures the key by reading the input value.
    dummyInput.addEventListener('keyup', handleDummyInputKeyUp);
    dummyInput.addEventListener('input', handleDummyInput);
    dummyInput.addEventListener('blur', unselectChar);

    document
      .querySelectorAll('.hide-button')
      .forEach((hideButton) =>
        hideButton.addEventListener('click', toggleHideNextElement)
      );

    document.querySelector('#reset').addEventListener('click', reset);

    document.querySelector('#clear').addEventListener('click', clear);
  </script>
</html>
