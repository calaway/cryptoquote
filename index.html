<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cryptoquote</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“œ</text></svg>"
    />
  </head>

  <body>
    <main id="main">
      <h1>Cryptoquote</h1>
      <hr />

      <section>
        <hgroup>
          <h4>Enter ciphertext</h4>
          <button class="hide-button">Hide</button>
        </hgroup>
        <div class="hideable">
          <textarea
            id="ciphertext-input"
            placeholder="Enter Cryptoquote text"
          ></textarea>
          <button id="reset">Reset</button>
        </div>
      </section>
      <hr />

      <section>
        <h4>Ciphertext</h4>
        <p id="ciphertext"></p>
      </section>
      <hr />

      <section>
        <h4>Plaintext</h4>
        <p id="plaintext"></p>
        <button id="clear">Clear</button>
        <input type="text" id="dummy-input" />
      </section>
      <hr />

      <section>
        <p>
          <span style="font-weight: bold">Unused:</span>
          <span id="unused-letters"></span>
        </p>
        <p>
          <span style="font-weight: bold">Used:</span>
          <span id="used-letters"></span>
        </p>
      </section>
      <hr />

      <section>
        <hgroup>
          <h4>Hint: Character tally</h4>
          <button class="hide-button">Show</button>
        </hgroup>
        <div class="hideable" hidden>
          <p id="ciphertext-char-tally"></p>
        </div>
      </section>
    </main>
  </body>

  <style>
    html {
      font-family: 'Courier New', Courier, monospace;
      font-size: x-large;
      background-image: url(./images/background.jpg);
      background-size: cover;
    }
    #main {
      max-width: 500px;
      margin: auto;
    }
    hgroup {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #ciphertext-input {
      width: 100%;
      height: 100px;
    }
    .highlight {
      background-color: yellow;
    }
    .char {
      margin-right: 0.2rem;
    }
    [data-used-letter] {
      text-decoration: line-through;
    }
    #dummy-input {
      position: absolute;
      left: -9999px;
    }
  </style>

  <script>
    const ciphertextInputElement = document.querySelector('#ciphertext-input');
    const ciphertextElement = document.querySelector('#ciphertext');
    const plaintextElement = document.querySelector('#plaintext');
    const unusedLettersElement = document.querySelector('#unused-letters');
    const usedLettersElement = document.querySelector('#used-letters');
    const ciphertextCharTallyElement = document.querySelector(
      '#ciphertext-char-tally'
    );
    const dummyInput = document.querySelector('#dummy-input');
    let selectedChar;
    let translationMap = {};

    function renderCiphertextInput() {
      ciphertextInputElement.value = localStorage.ciphertext;
    }

    function renderCiphertext() {
      ciphertextElement.innerHTML = localStorage.ciphertext
        .replace(
          /\w/g,
          (char) =>
            `<span class='char' data-ciphertext-char=${char}>${char}</span>`
        )
        .replace(/\n/g, '<br />');
    }

    function renderPlaintext() {
      plaintextElement.innerHTML = localStorage.ciphertext
        .replace(
          /\w/g,
          (char) => `<span class='char' data-ciphertext-char=${char}>_</span>`
        )
        .replace(/\n/g, '<br />');
      document
        .querySelectorAll('p#plaintext .char')
        .forEach((plaintextCharElement) => {
          plaintextCharElement.innerHTML =
            translationMap[
              plaintextCharElement.getAttribute('data-ciphertext-char')
            ] || '_';
        });
    }

    function addClickListeners() {
      const allCharElements = document.querySelectorAll('.char');
      allCharElements.forEach((charElement) => {
        charElement.addEventListener('click', () => {
          allCharElements.forEach((charElement) =>
            charElement.classList.remove('highlight')
          );
          selectedChar = charElement.getAttribute('data-ciphertext-char');
          const selectedCharElements = document.querySelectorAll(
            `.char[data-ciphertext-char=${selectedChar}`
          );
          selectedCharElements.forEach((selectedCharElement) =>
            selectedCharElement.classList.add('highlight')
          );
          dummyInput.focus();
        });
      });
    }

    function renderAlphabet() {
      const usedLetters = Object.values(translationMap).sort();
      const unusedLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        .split('')
        .filter((char) => !usedLetters.includes(char));

      unusedLettersElement.innerHTML = unusedLetters
        .map((char) => `<span class='char'>${char}</span>`)
        .join('');
      usedLettersElement.innerHTML = usedLetters
        .map((char) => {
          const dataCiphertextChar = Object.entries(translationMap).find(
            ([key, value]) => value === char
          )[0];
          return `<span class='char' data-ciphertext-char=${dataCiphertextChar} data-used-letter>${char}</span>`;
        })
        .join('');
    }

    function renderCharTally() {
      const ciphertextCharTally = {};
      localStorage.ciphertext
        .replace(/[^A-Z]/g, '')
        .split('')
        .forEach((char) =>
          ciphertextCharTally[char]
            ? (ciphertextCharTally[char] += 1)
            : (ciphertextCharTally[char] = 1)
        );
      ciphertextCharTallyElement.innerHTML = Object.entries(ciphertextCharTally)
        .sort(([_char1, tally1], [_char2, tally2]) => tally2 - tally1)
        .map(
          ([char, tally]) =>
            `<span class="char" data-ciphertext-char=${char}>${char}</span>: ${tally}`
        )
        .join('<br />');
    }

    function load() {
      localStorage.ciphertext = localStorage.ciphertext || '';
      renderCiphertextInput();
      renderCiphertext();
      renderPlaintext();
      renderAlphabet();
      renderCharTally();
      addClickListeners();
    }

    load();

    ciphertextInputElement.addEventListener('input', (event) => {
      localStorage.ciphertext = event.target.value.toUpperCase();
      renderCiphertextInput();
      renderCiphertext();
      renderPlaintext();
      renderCharTally();
      addClickListeners();
    });

    function unselectChar() {
      document
        .querySelectorAll('.char')
        .forEach((charElement) => charElement.classList.remove('highlight'));

      selectedChar = null;
    }

    function handleDummyInputKeyUp(event) {
      if (!selectedChar) return;
      const key = event.key;
      if (key === 'Escape') {
        unselectChar();
      } else if (key === 'Backspace' || key === 'Delete') {
        delete translationMap[selectedChar];
        renderPlaintext();
        addClickListeners();
        unselectChar();
      }
    }

    function handleDummyInput() {
      const dummyInputValue = dummyInput.value.toUpperCase();
      dummyInput.value = null;

      if (!selectedChar) {
        console.error('No character selected');
        return;
      } else if (!dummyInputValue.match(/^[A-Z]$/)) {
        console.error('Input more than a single character: ', dummyInputValue);
        return;
      }

      Object.entries(translationMap).forEach(
        ([ciphertextChar, plaintextChar]) => {
          if (plaintextChar === dummyInputValue) {
            delete translationMap[ciphertextChar];
          }
        }
      );

      translationMap[selectedChar] = dummyInputValue;
      renderPlaintext();
      renderAlphabet();
      addClickListeners();

      dummyInput.blur();
    }

    // The purpose of this dummy input is twofold: 1) mobile keyboards won't come up unless an input field is in focus, and 2) mobile keyboards (specifically Android) don't recognize the `event.key` on keydown/keyup events, so this captures the key by reading the input value.
    dummyInput.addEventListener('keyup', handleDummyInputKeyUp);
    dummyInput.addEventListener('input', handleDummyInput);
    dummyInput.addEventListener('blur', unselectChar);

    function toggleHideNextElement(event) {
      const hideableElement = event.target.parentElement.parentElement.querySelector(
        '.hideable'
      );
      hideableElement.toggleAttribute('hidden');
      if (hideableElement.hidden) {
        event.target.innerHTML = 'Show';
      } else {
        event.target.innerHTML = 'Hide';
      }
    }

    document
      .querySelectorAll('.hide-button')
      .forEach((hideButton) =>
        hideButton.addEventListener('click', toggleHideNextElement)
      );

    function reset() {
      localStorage.clear();
      load();
    }

    document.querySelector('#reset').addEventListener('click', reset);

    function clear() {
      translationMap = {};
      load();
    }

    document.querySelector('#clear').addEventListener('click', clear);
  </script>
</html>
