<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#4285f4" />
    <title>Cryptoquote</title>
    <link rel="shortcut icon" href="src/images/icon.svg" type="image/svg" />
    <link rel="manifest" href="manifest.webmanifest" />
  </head>

  <body>
    <main id="main">
      <h1>Cryptoquote</h1>
      <hr />

      <section>
        <details open>
          <summary>Enter encrypted text</summary>
          <div id="ciphertext-input-container">
            <textarea
              id="ciphertext-input"
              placeholder="Enter encrypted text"
            ></textarea>
          </div>
          <a href="#" id="reset">Reset</a>
        </details>
      </section>
      <hr />

      <section>
        <p id="ciphertext" data-selected-index="0"></p>
      </section>

      <section>
        <input type="text" id="dummy-input" tabindex="-1" />
        <p id="plaintext" data-selected-index="0"></p>
        <a href="#" id="clear">Clear</a>
      </section>
      <hr />

      <section>
        <h5>Remaining letters</h5>
        <p id="unused-letters"></p>
        <p id="used-letters" data-selected-index="0"></p>
      </section>
      <hr />

      <section>
        <details>
          <summary>Hint: Character counts</summary>
          <p id="ciphertext-char-tally" data-selected-index="0"></p>
          <hr />
        </details>
      </section>

      <section>
        <details>
          <summary>Hint: Suggestions</summary>
          <p>Click on a word to generate suggestions:</p>
          <p id="suggestions-ciphertext"></p>
          <p id="suggestions-list"></p>
        </details>
      </section>
    </main>
  </body>

  <style>
    html {
      font-family: 'Courier New', Courier, monospace;
      font-size: x-large;
      overflow-wrap: break-word;
      background-image: url(./src/images/background.jpg);
      background-size: cover;
    }
    #main {
      max-width: 500px;
      margin: auto;
    }
    h1,
    h5 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }
    a.unstyled-link {
      text-decoration: none;
      color: black;
    }
    #reset,
    #clear {
      font-size: medium;
    }
    #ciphertext-input-container {
      padding: 0 20px 0 20px;
    }
    #ciphertext-input {
      width: 100%;
      height: 100px;
    }
    .highlight {
      background-color: yellow;
    }
    .char {
      margin-right: 0.1rem;
    }
    #plaintext .char {
      text-decoration: underline;
      text-decoration-color: black;
      text-decoration-thickness: 1px;
    }
    .char[data-used-letter] {
      color: gray;
      text-decoration: line-through;
    }
    #dummy-input {
      position: absolute;
      left: -9999px;
    }
    #ciphertext-char-tally {
      display: grid;
      grid-auto-flow: column;
      grid-template-rows: repeat(9, auto);
      grid-template-columns: repeat(3, auto);
    }
    #suggestions-ciphertext .word {
      letter-spacing: 0.1rem;
    }
  </style>

  <script>
    /**
     * HTML elements
     */
    const ciphertextInputElement = document.querySelector('#ciphertext-input');
    const ciphertextElement = document.querySelector('#ciphertext');
    const plaintextElement = document.querySelector('#plaintext');
    const unusedLettersElement = document.querySelector('#unused-letters');
    const usedLettersElement = document.querySelector('#used-letters');
    const ciphertextCharTallyElement = document.querySelector(
      '#ciphertext-char-tally'
    );
    const suggestionsCiphertextElement = document.querySelector(
      '#suggestions-ciphertext'
    );
    const suggestionsListElement = document.querySelector('#suggestions-list');
    const dummyInput = document.querySelector('#dummy-input');

    /**
     * Global variables
     */
    let selectedChar;
    let translationMap = {};
    let commonWords;
    let selectedTabGroupElement = ciphertextElement;

    /**
     * Update state
     */
    function updateCiphertext(newCiphertext) {
      localStorage.ciphertext = newCiphertext.toUpperCase();
      renderCiphertext();
      renderPlaintext();
      renderCharTally();
      renderSuggestionsCiphertext();
    }

    /**
     * Update DOM
     */
    async function renderCiphertextInput() {
      ciphertextInputElement.value = localStorage.ciphertext;
    }

    async function renderCiphertext() {
      ciphertextElement.innerHTML = localStorage.ciphertext
        .split('')
        .map((char, index) => {
          if (Object.keys(translationMap).includes(char)) {
            return `<a href="#" class="char unstyled-link" data-ciphertext-char="${char}" data-used-letter>${char}</a>`;
          } else if (/[A-Z]/.test(char)) {
            return `<a href="#" class="char unstyled-link" data-ciphertext-char="${char}">${char}</a>`;
          } else if (char === '\n') {
            return '<br />';
          } else {
            return char;
          }
        })
        .join('');
      addClickListeners(ciphertextElement);
    }

    async function renderPlaintext() {
      plaintextElement.innerHTML = localStorage.ciphertext
        .split('')
        .map((char, index) => {
          if (translationMap[char]) {
            return `<a href="#" class="char unstyled-link" data-ciphertext-char="${char}">${translationMap[char]}</a>`;
          } else if (/[A-Z]/.test(char)) {
            // Using transparent '_' instead of ' ' for testability
            return `<a href="#" class="char unstyled-link" data-ciphertext-char="${char}" style='color: transparent;'>_</a>`;
          } else if (char === '\n') {
            return '<br />';
          } else {
            return char;
          }
        })
        .join('');
      addClickListeners(plaintextElement);
    }

    async function renderUsedLetters() {
      const usedLetters = Object.values(translationMap).sort();
      const unusedLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        .split('')
        .filter((char) => !usedLetters.includes(char));

      unusedLettersElement.innerHTML = unusedLetters
        .map((char) => `<span class="char">${char}</span>`)
        .join('');
      usedLettersElement.innerHTML = usedLetters
        .map((char) => {
          const dataCiphertextChar = Object.entries(translationMap).find(
            ([key, value]) => value === char
          )[0];
          return `<a href="#" class="char unstyled-link" data-ciphertext-char="${dataCiphertextChar}" data-used-letter>${char}</a>`;
        })
        .join('');
      usedLettersElement.dataset.selectedIndex = 0;
      addClickListeners(usedLettersElement);
    }

    async function renderCharTally() {
      const ciphertextCharTally = {};
      localStorage.ciphertext
        .replace(/[^A-Z]/g, '')
        .split('')
        .forEach((char) =>
          ciphertextCharTally[char]
            ? (ciphertextCharTally[char] += 1)
            : (ciphertextCharTally[char] = 1)
        );
      const rowCount = Math.ceil(Object.keys(ciphertextCharTally).length / 3);
      ciphertextCharTallyElement.style[
        'grid-template-rows'
      ] = `repeat(${rowCount}, auto`;
      ciphertextCharTallyElement.innerHTML = Object.entries(ciphertextCharTally)
        .sort(([_char1, tally1], [_char2, tally2]) => tally2 - tally1)
        .map(([char, tally]) => {
          const isUsedLetter = Object.keys(translationMap).includes(char);
          return `<div><a href="#" class="char unstyled-link" data-ciphertext-char="${char}" ${
            isUsedLetter ? 'data-used-letter' : ''
          }>${char}: ${tally}</a></div>`;
        })
        .join('');
      addClickListeners(ciphertextCharTallyElement);
    }

    async function renderSuggestionsCiphertext() {
      suggestionsCiphertextElement.innerHTML = localStorage.ciphertext
        .replace(
          /[\w'’]+/g,
          (word) => `<a href="#" class="word unstyled-link">${word}</a>`
        )
        .replace(/\n/g, '<br />');
    }

    async function renderSuggestionsList(clickEvent) {
      clickEvent.preventDefault();
      const clickedWord = clickEvent.target.innerText;
      commonWords =
        commonWords ||
        (await fetch('src/words.txt')
          .then((response) => response.text())
          .then((txt) => txt.split('\n')));
      let words = commonWords;
      words = words.filter((word) => word.length === clickedWord.length);
      clickedWord.split('').forEach((charA, indexA) => {
        if (charA === "'" || charA === '’') {
          words = words.filter((word) => word[indexA] === "'");
        }
        if (translationMap[charA]) {
          words = words.filter(
            (word) => word[indexA].toUpperCase() === translationMap[charA]
          );
        } else {
          words = words.filter((word) => {
            const usedLetters = Object.values(translationMap);
            return !usedLetters.includes(word[indexA].toUpperCase());
          });
        }
        clickedWord
          .slice(indexA + 1)
          .split('')
          .forEach((charB, indexB) => {
            words = words.filter(
              (word) =>
                (charA === charB) ===
                (word[indexA] === word[indexA + indexB + 1])
            );
          });
      });
      const numberOfWordsToShow = 12;
      suggestionsListElement.innerHTML = `Suggestions:<br />${words
        .slice(0, numberOfWordsToShow)
        .map(
          (word) =>
            `<a href="#" class="suggested-word unstyled-link">${word}</a>`
        )
        .join(', ')}${words.length > numberOfWordsToShow ? ', ...' : ''}`;
      suggestionsListElement
        .querySelector('.suggested-word:first-of-type')
        ?.scrollIntoView();
      suggestionsListElement
        .querySelectorAll('.suggested-word')
        .forEach((suggestedWord) => {
          suggestedWord.addEventListener('click', (clickEvent) => {
            clickEvent.preventDefault();
            clickEvent.target.innerText
              .replace(/\W/g, '')
              .split('')
              .forEach((char, index) => {
                const ciphertextChar = clickedWord.replace(/\W/g, '')[index];
                translationMap[ciphertextChar] = char.toUpperCase();
              });
            renderCiphertext();
            renderPlaintext();
            renderUsedLetters();
            renderCharTally();
            unselectChar();
          });
        });
    }

    function addClickListeners(charGroupElement) {
      function modulo(a, n) {
        return ((a % n) + n) % n;
      }
      charGroupElement
        .querySelectorAll('.char')
        .forEach((charElement, index) => {
          charElement.addEventListener('click', (clickEvent) => {
            clickEvent.preventDefault();
            selectedTabGroupElement = charGroupElement;
            charGroupElement.querySelector('.char[tabindex="0"]').tabIndex = -1;
            charGroupElement.dataset.selectedIndex = index;
            clickEvent.target.tabIndex = 0;
            document
              .querySelectorAll('.char')
              .forEach((charElement) =>
                charElement.classList.remove('highlight')
              );
            selectedChar = charElement.getAttribute('data-ciphertext-char');
            const selectedCharElements = document.querySelectorAll(
              `.char[data-ciphertext-char="${selectedChar}"]`
            );
            selectedCharElements.forEach((selectedCharElement) =>
              selectedCharElement.classList.add('highlight')
            );
            const xPosition = window.scrollX;
            const yPosition = window.scrollY;
            dummyInput.focus();
            window.scroll(xPosition, yPosition);
          });

          const selectedIndex = charGroupElement.dataset.selectedIndex;
          const tabindex = index == selectedIndex ? 0 : -1;
          charElement.tabIndex = tabindex;

          charElement.addEventListener('keydown', (keydownEvent) => {
            let increment;
            if (
              keydownEvent.key === 'ArrowLeft' ||
              keydownEvent.key === 'ArrowUp'
            ) {
              increment = -1;
            } else if (
              keydownEvent.key === 'ArrowRight' ||
              keydownEvent.key === 'ArrowDown'
            ) {
              increment = +1;
            } else {
              return;
            }
            keydownEvent.preventDefault();
            keydownEvent.target.tabIndex = -1;
            const charCount = charGroupElement.querySelectorAll('.char').length;
            const selectedIndex = modulo(
              parseInt(charGroupElement.dataset.selectedIndex) + increment,
              charCount
            );
            charGroupElement.dataset.selectedIndex = selectedIndex;
            // console.log('selectedIndex: ', selectedIndex);
            // debugger;
            const newSelectedElement = charGroupElement.querySelectorAll(
              '.char'
            )[selectedIndex];
            newSelectedElement.tabIndex = 0;
            newSelectedElement.focus();
          });
        });
    }

    function unselectChar() {
      document
        .querySelectorAll('.char')
        .forEach((charElement) => charElement.classList.remove('highlight'));

      selectedChar = null;
    }

    function handleDummyInputKeyUp(event) {
      if (!selectedChar) return;
      const key = event.key;
      if (key === 'Escape') {
        unselectChar();
      } else if (key === 'Backspace' || key === 'Delete') {
        delete translationMap[selectedChar];
        renderCiphertext();
        renderPlaintext();
        renderUsedLetters();
        renderCharTally();
        unselectChar();
      }
    }

    function handleDummyInput() {
      const dummyInputValue = dummyInput.value.toUpperCase();
      dummyInput.value = null;

      if (!selectedChar) {
        console.error('No character selected');
        return;
      } else if (!dummyInputValue.match(/^[A-Z]$/)) {
        console.error('Input more than a single character: ', dummyInputValue);
        return;
      }

      Object.entries(translationMap).forEach(
        ([ciphertextChar, plaintextChar]) => {
          if (plaintextChar === dummyInputValue) {
            delete translationMap[ciphertextChar];
          }
        }
      );

      translationMap[selectedChar] = dummyInputValue;
      renderCiphertext();
      renderPlaintext();
      renderUsedLetters();
      renderCharTally();

      dummyInput.blur();
      selectedTabGroupElement.querySelector('.char[tabindex="0"]')?.focus();
    }

    function reset(clickEvent) {
      clickEvent.preventDefault();
      localStorage.clear();
      translationMap = {};
      load();
    }

    function load() {
      ciphertext = localStorage.ciphertext || '';
      updateCiphertext(ciphertext);
      renderCiphertextInput();
      renderUsedLetters();
    }

    function clear(clickEvent) {
      clickEvent.preventDefault();
      translationMap = {};
      load();
    }

    load();

    /**
     * Add event listeners
     */
    ciphertextInputElement.addEventListener('input', (event) =>
      updateCiphertext(event.target.value)
    );

    // The purpose of this dummy input is twofold: 1) mobile keyboards won't come up unless an input field is in focus, and 2) mobile keyboards (specifically Android) don't recognize the `event.key` on keydown/keyup events, so this captures the key by reading the input value.
    dummyInput.addEventListener('keyup', handleDummyInputKeyUp);
    dummyInput.addEventListener('input', handleDummyInput);
    dummyInput.addEventListener('blur', unselectChar);

    document.querySelector('#reset').addEventListener('click', reset);

    document.querySelector('#clear').addEventListener('click', clear);

    suggestionsCiphertextElement.addEventListener(
      'click',
      renderSuggestionsList
    );

    /**
     * Progressive web app service worker
     */
    window.addEventListener('load', () => {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./service-worker.js');
      }
    });
  </script>
</html>
